# F6必答题

## 功能完备的迷你RISC-V处理器

### 1.RTFM(1)

![image-20260118112954939](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118112954939.png)

答：

1.PC寄存器的位宽是32bit； 

2.GPR共有32个，每个GPR的位宽是32bit；

3.RV321里面的寄存器 x0 硬连接为全零，即R0里面的值固定为常数零，而sISA的R0的值并非是固定的；

4.所有指令的长度都是固定的 32 位，四种核心指令格式（R/I/S/U）；

5.需要5bit表示一个GPR，因为一共有32个GPR；

6.add指令应该是R-Type，因为需要三个寄存器，

![image-20260118115456575](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118115456575.png)

7.RV32E 是 RV32I 的简化版，具体来说，它们唯一的变化是将整数寄存器的数量减少到 16个。

### 2.RTFM(2)

![image-20260118120556553](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118120556553.png)

addi指令是I型指令，指令编码如下，
![image-20260118121155717](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118121155717.pnghttps://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119122816098.png)

具体功能是：

ADDI 指令对寄存器 rs1 的值与符号扩展的 12 位立即数进行加法运算。算术溢出被忽略，结果仅保留低 XLEN 位。ADDI rd, rs1, 0 用于实现汇编伪指令 MV rd, rs1。

### 3.RTFM(3)

![image-20260118121922580](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118121922580.png)

![image-20260118164222707](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118164222707.png)

### 4.RTFM(4)

![image-20260118123415727](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118123415727.png)

jalr指令是I型指令，指令编码如下，

![image-20260118121123829](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118121123829.png)

![image-20260118123333574](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118123333574.png)

具体功能是：

目标地址由寄存器 rs1与符号扩展的 12 位 I 型立即数相加得到，并将计算结果的最低有效位清零。跳转指令后续指令的地址（pc+4）被写入寄存器 rd。如果不需要保存返回地址，可以使用寄存器 x0 作为目标寄存器。

“将计算结果的最低有效位清零”——因为需要4字节对齐，所以PC必须是偶数，所以最低字节清零可以变成偶数。

为啥是PC+4？——因为是32bit，一条指令占4字节。

### 5~7. 实现8条指令的minirv处理器

![image-20260118171211397](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118171211397.png)

![image-20260118220238448](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118220238448.png)

![image-20260123210736576](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260123210736576.png)

设计还是分为：取指，译码，执行

#### 取指和译码

核心：最重要的是搞清楚8条指令的含义，以及各个寄存器的如何生成数据和地址。

##### 1）addi指令——sel=0

对寄存器 rs1 的值与符号扩展的 12 位立即数进行加法运算作为wdata，结果存入rd中。算术溢出被忽略，结果仅保留低 XLEN 位。

```
addi    rd, rs1, imm
```

![image-20260118121155717](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118121155717.png)

###### 译码操作：

读rs1  +  imm 作为 wdata

rd 作为 waddr，存入rd寄存器

##### 2）add指令——sel=3

对寄存器 rs1 的值与寄存器rs2的值进行加法运算作为wdata，结果存入rd中。算术溢出被忽略，结果仅保留低 XLEN 位。

```
add    rd, rs1, rs2
```

![image-20260119122816098](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119122816098.png)
![image-20260119095129300](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119095129300.png)

###### 译码操作：

读rs1  +  读rs2 作为 wdata

rd 作为 waddr，存入rd寄存器

##### 3）访存指令：lw和lbu，sw和sb

以上访存指令均遵循：有效地址由寄存器 rs1 与经过符号扩展的 12 位偏移量相加得到。加载指令从内存读取值并存入寄存器 rd；存储指令则将寄存器 rs2 的值写入内存。

![image-20260119163747841](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119163747841.png)

###### lw指令——sel=4

将一个 32 位的值从内存加载到寄存器 rd 中。

```
lw    rd, rs1, imm
lw    rd, imm(rs1)
```

![image-20260118181932966](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118181932966.png)

译码操作：

根据指令计算内存地址→从内存取data→把32位data存到寄存器rd中。

读rs1  +  imm 作为 内存的raddr，

从内存读出的data 作为 寄存器的wdata，

rd 作为 waddr，再存入rd寄存器。

###### lbu指令——sel=6

基本和lw指令一样，不同的是32位变为8位，并且是无符号数进行零扩展，将一个 8 位的值从内存加载到寄存器 rd 中。

```
lbu    rd, rs1, imm
lbu    rd, imm(rs1)  
```

![image-20260119100514741](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119100514741.png)

译码操作：

根据指令计算内存地址→从内存取data→把8位data存到寄存器rd中。

读rs1  +  imm 作为 内存的addr，

从内存读出的8bit的data进行零扩展位32bit数据  作为 寄存器的wdata，

重点——读哪一个字节，需要根据内存地址的后2位进行选择，

rd作为 waddr，再存入rd寄存器。

eg：读取地址为rs1+1，根据地址的末2bit，假设是3，则取出最高位的字节，假设该字节是0x56(零扩展后为0x00000056)，再存入rd。

###### sw指令——sel=5 

从寄存器 rs2 的低位中取出 32位数据存入内存——从寄存器rs2中取32位data→再计算内存地址，即imm+rs1→存入内存。

```
sw     rd, rs1, imm
sw     rd, imm(rs1)  
```

![image-20260119100737758](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119100737758.png)

译码操作：

读rs2的值    作为   内存的wdata，

读rs1的值+imm  作为   内存的waddr。  

###### sb指令——sel=7

从寄存器 rs2 的低位中取出 8 位数据存入内存——从寄存器rs2中取8位data→再计算内存地址，即imm+rs1→存入内存。

```
sb     rd, rs1, imm
sb     rd, imm(rs1)  
```

![image-20260119100922151](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119100922151.png)

译码操作：

读rs2的值的后8bit，进行扩展后    作为   内存的wdata，

读rs1的值+imm  作为   内存的waddr。  

如何扩展？——依据目录搜索  “  2）sb指令：选择哪一个字节读写？”

##### 4）jalr指令——sel=1

目标地址由寄存器 rs1与符号扩展的 12 位 I 型立即数相加得到，并将计算结果的最低有效位清零。跳转指令后续指令的地址（pc+4）被写入寄存器 rd。如果不需要保存返回地址，可以使用寄存器 x0 作为目标寄存器。

```
jalr	rd,rs1,imm
jalr	rd,imm(rs1)
```

![image-20260118123333574](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260118123333574.png)

###### 译码操作：

读rs1的值+imm 并且将计算结果的最低有效位清零    作为   跳转PC，

再把jalr指令的下一条指令地址存入寄存器rd中（具体方式搜索目录“PC不匹配的延伸问题：jalr指令如何实现保存下一条PC？”）。

##### 5）lui指令——sel=2 

lui（Load Upper Immediate）用于构造 32 位常数，采用 U 型格式。LUI 将 32 位 U-立即数 载入目标寄存器 rd，并在最低 12 位补0。无论正数，还是负数。

```
lui	rd,imm
```

![image-20260119095332967](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260119095332967.png)

###### 译码操作：

imm在最低位12bit补0后  作为   wdata，存入rd寄存器。

#### 执行

取指和译码完成后就是执行啦，通过上面分析的就可以搭建电路啦，理论上很直观，按照译码操作的逻辑搭建电路其实不难，注意下连线细节细心一点就好。剩下的就是实操有非常多的细节需要注意，个人认为最重要的是ISA层次和电路层次的存储器位数是不同的，设计电路的时候需要尤为注意。

看了课件才知道译码实现使用比较器最好，我特意找了下八条指令的op部分特点，利用译码器和MUX实现的，弄得特别复杂，其实可以优化一下。

### 8.设计miniRISC-V处理器的bug

#### 1）存储器位宽引起的地址不匹配问题

##### 无法正确读取下一条PC：

由于存储器位宽在ISA层次和电路层次不相同，

- 在ISA层次, PC寄存器是以PC+4为单位寻址；
- 电路层次的存储器位宽RAM是以PC+1来取指的， 则不能直接用PC直接进行寻址。

指令里面生成的都是ISA层次的PC+4，而非电路层次的PC+1。

##### RAM读写地址不匹配：

发现这个问题是我译码以后生成的内存地址在hex文件里读出的数据都是零，所以我觉得肯定是内存地址有问题，于是我联想PC的问题，认为ROM和RAM使用的是一套地址划分方式，包括后面的RGB也是一样，所以应该是一个电路层次的组件都是同一套地址划分方式。

##### 解决办法：

也就是说相当于ISA层次的“4”等于电路层次的“1”，经过4倍等比例放缩。

处理PC我选择首先  生成ISA层次的PC+4和存储地址，再把它们转化成电路层次的，可以简单理解为都除以4，遇到jalr指令分为需要跳转和不需要跳转2种情况，需要跳转就直接除以4，不需要跳转就加4再减3，即加1，非要这么写是因为我想把ISA的PC和电路层次的PC分层；处理内存地址可以使用移位器实现，能同时到达存储地址末尾2bit清零的效果。

##### PC不匹配的延伸问题：jalr指令如何实现保存下一条PC？

在层次不匹配的情况下，返回的PC实际上是电路层次的，但是程序运行是按照ISA层次运行的，所以保存的下一条PC的地址就需要转化为ISA层次的，但是这样很麻烦，我选择解决办法是在jalr未跳转时，就预存下一条PC+4，可以完美解决这个矛盾。

还有一个，生成的PC是32bit，先不要缩成RAM的addr数（最高20bit），会使RGB的地址24bit变得不完整，从而无法选中正确的元件。

可以看到这个问题很有电路特性，就是设计需要考虑电路本身的特点才能正确设计出来。

#### 2）sb指令：选择哪一个字节读写？

lbu指令和sb指令的区别：lbu读取的话可以先读出整个32bit数据，再按照地址最后两位选择读哪一个字节。但是sb指令需要选定1字节再读入内存，并且不能覆盖内存其他字节的数据。

sb指令的实现：内存读进去是只能数据是4字节的，所以必须根据sb指令选中的字节编号生成一个4字节的数据，再根据内存的字节编号写使能写入内存对应位置。比如sb指令需要写入数据89H，写入的字节编号是2，所以生成的data=00890000H，写能使Wen=M6=1，其余均为0，这样就能完美读入正确的数据，且不发生覆盖。

#### 3）使用封装子电路设计电路

一开始我没有使用分块的方式设计电路，找bug特别慢，而且脑子里很乱，挣扎了2天我重新封装了一下，分为PC寄存器，译码器，GPRs处理，内存数据处理，RGB选择器这几个子电路，果然清晰很多，封装的过程又找到几个逻辑上的电路错误，具体是啥不记得啦，反正这个方法挺好用的。

隧道：还有一个组件叫隧道，由于是设计了一半才发现有这个组件，对它不太熟系，粗浅看了下说明书没太理解（脑子里全是对指令运行不出来的回响），所以就舍弃隧道使用了连线，现在知道怎么使用啦，后面有机会使用一下。

#### 4）Logisim_evolution使用问题

在需要重新运行程序时，我发现2次的运行结果会不一致，第一次运行成功，即使GPRs清零后再运行一次还是会死循环。

##### 解决办法：

再一次运行时，务必要把GPRs清零，然后内存RAM里面的数据要重新加载2遍，官方原理不清楚，个人理解是程序运行后会更改或者增加原有的数据，所以必须完全置位才能正常运行。

#### 5）调试bug技巧

##### 通过模拟ISA流程找bug

这个方法很费时间，但是确实很有效。

我是通过一类指令进行测试的，可以先测试addi类，因为后面的指令可以利用addi来赋值操作。

- step1：先让deepseek写几条addi指令，测试负数正数，边界都写几条，并且生成每条指令执行后寄存器的值；

- step2：再汇编语言转机器码：在一生一芯交流群里有一个同学编写了一个可以通过汇编语言转化机器码的软件，支持批量转换，我利用vs运行了一下非常好用！之所以不用deepseek生成机器码是因为会出错，AI也不准，试了几次发现它生成的机器码会错，会影响ISA结果，干脆机器码自己手动生成。

- step3：最后对比自己的处理器和ISA的状态是否相同。

一共有8组，全测试一遍，工作量很大，最好还是设计电路的时候小心一些，而且基本这些指令最好都要测试处理负数的能力，因为给的程序里面基本上都有负数需要处理。

##### 通过观察存储器读取内容

可以通过观察存储器读取的内容来反推自己的程序是否符合ISA，上面方法是具体的，这个就是宏观逻辑上的，比如读取fffffef，一般是对的，比如读取的内容是零，并且它的附近地址的内容都是零，大概是内存地址生成错啦，所以读不出来，这个时候就倒回去看影响内存地址的寄存器在什么位置更改啦，或者就是出错指令的上几条指令有问题。

## 运行成功结算画面！

![image-20260124150515832](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260124150515832.png)

视频链接：【一生一芯F6_minirv处理器-运行打印logo-哔哩哔哩】 https://b23.tv/Oh6TFhl

sum和mem运行的结果是：在3000个左右时钟后会一直循环halt，并且a0(x10)=0，必须两个条件同时满足才对，三个程序使用的是同一套电路，就是RGB多了一个选择器和视频功能。

## 反思

​          通过Logisim_evolution设计处理器其实并不高效，而且很受限，比如不同的电路有不同的规格就会影响处理器的设计和功能实现，RISC-V32l规定PC=32bit，但是Logisim_evolution里面的ROM和RAM的addr最高只有20bit，同时需要考虑地址和PC层次转化的问题。还有我设计的电路里面有些比较繁琐，其实可以用更少的部件去实现，出于能跑就不去改的原则（以及懒得再改）我只修改了一部分子电路，但是有些地方其实可以更加优化。不过答疑会上助教们也说过，后面是拿代码设计处理器，可以暂时不考虑优化电路。

​          这次的电路设计经历让我感觉：嘿！设计处理器还挺好玩的。设计完找bug很痛苦，但是当点击Ctrl+k后看到logo一点点加载出来，那一刻的成就感是任何娱乐项目都无法替代的，经历了整整六天的设计，算是自己的第一个处理器问世了吧，后面就是代码的世界啦，加油！再接再厉！


