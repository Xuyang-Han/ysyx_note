# F3必答题“一生一芯”

## F3.3—数字逻辑电路基础

### 1.分析门电路（晶体管电路）

![image-20260103143307119](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103143307119.png)



#### 分析：

1.当pMOS的栅极为0时，P1和P2串联导通，Y为1

2.当nMOS的栅极为1时，N1和N2并联导通，Y为0

|  A   |  B   |  Y   |
| :--: | :--: | :--: |
|  0   |  0   |  1   |
|  0   |  1   |  0   |
|  1   |  0   |  0   |
|  1   |  1   |  0   |

#### 总结：

N1和N2并联，导通一个即可；但P1和p2串联，必须同时导通



### 2.根据逻辑门画出晶体管结构

![image-20260103145158646](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103145158646.png)

#### 分析：

或门=或非门+非门，所以先画出或非门的晶体管结构，再加一个非门，一定要注意晶体管的方向，还有非门的方向——是从外指向内

连接晶体管电路图，必须遵循：

1.nMOS的源极接地，pMOS的源极接VCC

2.两个MOS串联，方向一致；nMOS和pMOS串联，方向相反，即漏对源

或门如下图：且测试所有输入输出均符合或门

![image-20260103153021658](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103153021658.png)

### 3.不同方式搭建<u>三输入与非门</u>

![image-20260103154341808](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103154341808.png)

对比门电路和晶体管搭建三输入与非门，所消耗的晶体管数量是否相同？（晶体管数量可等价于门电路的面积）

门电路：需要晶体管的数量（门电路的面积之和）=~~6+8=14~~    6+4=10

晶体管结构：需要晶体管的数量（门电路的面积之和）=3×1+3×3=12



#### 延伸笔记：N输入与非门计算门电路的面积

![image-20260103154911038](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103154911038.png)



### 4.搭建异或门

![image-20260103155833417](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103155833417.png)

逻辑门组成的门电路如下，预计转化成晶体管结构应该需要2×2+~~8×2~~+6＝~~26~~个晶体管，改为2×2+6×2+6＝22个晶体管

我的误区改正：根据门电路的搭建晶体管的设计，门电路面积＝晶体管数量（不考虑对等原则）。

![image-20260103155918583](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103155918583.png)

#### 延伸知识点：分析异或门全定制电路

![image-20260103161353829](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20260103161353829.png)

1.晶体管结构的非门必须是上面是VCC，下面是0，才能实现非门的功能；

2.传输门的话必须上下反着，且下面是1才能导通。



### 5.设计同或门

![image-20260103161537744](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103161537744.png)

##### 构建思路

门电路：在异或门的基础上，后面加一个非门就是同或门

晶体管结构：在全定制异或门的基础上，后面加一个非门就是同或门的全定制电路（设计出来的晶体管数量是8个）

门电路如下图：

![image-20260103170614729](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103170614729.png)

晶体管如下，但不优：

![image-20260103171314960](https://gitee.com/brownie145810/ysyx_pic/raw/master/image-20260103171314960.png)

### 小结

##### 连接晶体管电路图心得

一、连接晶体管电路图，必须遵循

1.nMOS的源极接地，pMOS的源极接VCC

2.两个MOS串联，方向一致；nMOS和pMOS串联，方向相反，即漏对源

二、这次连接的是异或门，还有一个问题是传输门接反了

三、经过这次调试，一个小心得就是排除电路图bug可以试着模拟一下电流的流向



## F3.4—整数的机器以及表示

![image-20260104105111756](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104105111756.png)

#### 1.八进制和十进制互转

十进制转八进制：把十进制写成  a×8的零次幂，b×8的1次幂，c×8的2次幂……之和，其中a，b，c为常数，然后仿照十进制转二进制从零次幂的位置开始写直到写完。

八进制转十进制：每个位的数值×对应的8的n次幂之和

#### 2.八进制和二进制互转

二进制转八进制：把二进制从低位起，每三位组成一个数，若高位不够三位则补零，直到二进制全部转化完成

八进制转二进制：每一个都写成三位二进制，从低位到高位依次拆分，最后按序组合到一起



## F3.5—通过门电路搭建基本组合逻辑电路

### 译码器

#### 1.搭建2-4_decoder

![](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104163336843.png)

**搭建小技巧**：先画对应的真值表，然后模拟A，B，Y的值的格子情况，确定要四个与门，所以必须是A=1和B=1同时满足，才能得到Y=1

**为什么是与门**：我个人的理解就是，与门为1的情况只有一种，所以符合独热码的特性，所以选与门

搭建门电路如下图，已通过测试：

![](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104160801124.png)

#### 2.把2-4_decoder封装成子电路，再构建3-8_decoder

![image-20260104175317651](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104175317651.png)

![image-20260104183039148](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104183039148.png)

##### 分析：

3-8_decoder的真值表如下图，可以看出除了当C=0和C=1时，对应后面的A和B的值是重复的，也就是说不考虑C的值，A和B可以构成两套2-4_decoder，如果在2-4_decoder里面加入选择位sel，那么就可以实现3-8_decoder

|  C   |  A   |  B   |      |  Y0  |  Y1  |  Y2  |  Y3  |  Y4  |  Y5  |  Y6  |  Y7  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |      |  1   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|  0   |  0   |  1   |      |  0   |  1   |  0   |  0   |  0   |  0   |  0   |  0   |
|  0   |  1   |  0   |      |  0   |  0   |  1   |  0   |  0   |  0   |  0   |  0   |
|  0   |  1   |  1   |      |  0   |  0   |  0   |  1   |  0   |  0   |  0   |  0   |
|  1   |  0   |  0   |      |  0   |  0   |  0   |  0   |  1   |  0   |  0   |  0   |
|  1   |  0   |  1   |      |  1   |  0   |  0   |  0   |  0   |  1   |  0   |  0   |
|  1   |  1   |  0   |      |  0   |  0   |  0   |  0   |  0   |  0   |  1   |  0   |
|  1   |  1   |  1   |      |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |

##### 设计步骤：

1.在2-4_decoder中加入sel，满足当sel=1时，2-4_decoder正常工作；当sel=0时，2-4_decoder全部输出0;

2.C是有效位，A和B是输入位，C=1时，低四位有效；C=0时，高四位有效



下图是，加入sel位的2-4_decoder（有思路但是不知道如何实现有效位sel，百度了一下，学到了三位与门——与(乘)一位1则还是等效二位与门，与(乘)一位0，则全部输出0）

![](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104195201872.png)



下图是2个2-4_decoder构成的3-8_decoder

![image-20260104194421598](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104194421598.png)

#### 3.搭建七段数码管译码器

![image-20260104200054006](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104200054006.png)

##### 分析：

七段数码管编号：其中，abcd位高四位，efgh为低四位

![image-20260106144659705](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260106144659705.png)

七段数码管显示数字与输出位的真值表（0-9显示数字，其余不显示）

| 显示 |  A   |  B   |  C   |  D   |      |  a   |  b   |  c   |  d   |  e   |  f   |  g   |  h   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |      |  0   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |
|  1   |  0   |  0   |  0   |  1   |      |  0   |  0   |  0   |  1   |  0   |  0   |  1   |  0   |
|  2   |  0   |  0   |  1   |  0   |      |  1   |  0   |  1   |  1   |  1   |  1   |  0   |  0   |
|  3   |  0   |  0   |  1   |  1   |      |  1   |  0   |  1   |  1   |  0   |  1   |  1   |  0   |
|  4   |  0   |  1   |  0   |  0   |      |  1   |  1   |  0   |  1   |  0   |  0   |  1   |  0   |
|  5   |  1   |  0   |  0   |  1   |      |  1   |  1   |  1   |  0   |  0   |  1   |  1   |  0   |
|  6   |  0   |  1   |  1   |  0   |      |  1   |  1   |  1   |  0   |  1   |  1   |  1   |  0   |
|  7   |  0   |  1   |  1   |  1   |      |  0   |  0   |  1   |  1   |  0   |  0   |  1   |  0   |
|  8   |  1   |  0   |  0   |  0   |      |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |
|  9   |  1   |  0   |  0   |  1   |      |  1   |  1   |  1   |  1   |  0   |  1   |  1   |  0   |

##### 设计思考以及我的bug：

1.我的bug：根据提示，我想的是以Yi为起点推理，一个Y对应一个或门，然后这个或门同时控制七段数码管的8个输出，但是做到一半卡住了，因为如果Yi=0，那么还是会有输出值，会出现一条线路上同时有两种高低电平的情况，矛盾电路图无法运行。

2.于是我问了一下AI，然后正确思路应该是以8个输出信号为起点，a段亮起时，分别对应哪几个Yi，再把这个几个Yi连接一个或门，只有有一个Yi=1，那么a段就亮起，若没有则a段不亮。

心情感悟：哇，可算画出来了，想了一天半，最后还是问了下ai，不知道这能不能进步，那先记住这个处理手法吧。



##### 设计如下：

（0-9均可实现，此图只展现数字9）

![image-20260106151037870](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260106151037870.png)



#### 4.搭建十六进制七段数码管

![image-20260106152228656](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260106152228656.png)

##### 分析:

是上面搭建而成的基础上做扩展即可，支持0-9十进制显示，还支持A,b,C,d,E,F的显示。

先画出真值表，重新连接或门与Yi，之后的步骤与构建0-9七段数码管一致。

七段数码管显示数字与输出位的真值表（0-9显示数字，其余显示A,b,C,d,E,F）

| 显示 |  A   |  B   |  C   |  D   |      |  a   |  b   |  c   |  d   |  e   |  f   |  g   |  h   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |      |  0   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |
|  1   |  0   |  0   |  0   |  1   |      |  0   |  0   |  0   |  1   |  0   |  0   |  1   |  0   |
|  2   |  0   |  0   |  1   |  0   |      |  1   |  0   |  1   |  1   |  1   |  1   |  0   |  0   |
|  3   |  0   |  0   |  1   |  1   |      |  1   |  0   |  1   |  1   |  0   |  1   |  1   |  0   |
|  4   |  0   |  1   |  0   |  0   |      |  1   |  1   |  0   |  1   |  0   |  0   |  1   |  0   |
|  5   |  1   |  0   |  0   |  1   |      |  1   |  1   |  1   |  0   |  0   |  1   |  1   |  0   |
|  6   |  0   |  1   |  1   |  0   |      |  1   |  1   |  1   |  0   |  1   |  1   |  1   |  0   |
|  7   |  0   |  1   |  1   |  1   |      |  0   |  0   |  1   |  1   |  0   |  0   |  1   |  0   |
|  8   |  1   |  0   |  0   |  0   |      |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |
|  9   |  1   |  0   |  0   |  1   |      |  1   |  1   |  1   |  1   |  0   |  1   |  1   |  0   |
|  A   |  1   |  0   |  1   |  0   |      |  1   |  1   |  1   |  1   |  1   |  0   |  1   |  0   |
|  b   |  1   |  0   |  1   |  1   |      |  1   |  1   |  0   |  0   |  1   |  1   |  1   |  0   |
|  C   |  1   |  1   |  0   |  0   |      |  0   |  1   |  1   |  0   |  1   |  1   |  0   |  0   |
|  d   |  1   |  1   |  0   |  1   |      |  1   |  0   |  0   |  1   |  1   |  1   |  1   |  0   |
|  E   |  1   |  1   |  1   |  0   |      |  1   |  1   |  1   |  0   |  1   |  1   |  0   |  0   |
|  F   |  1   |  1   |  1   |  1   |      |  1   |  1   |  1   |  0   |  1   |  0   |  0   |  0   |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |



##### 设计如下：

（0-F均可实现，此图只展现F）

![image-20260106163057427](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260106163057427.png)

#### 小结

##### 值得记录的Bug和调试心得

这次完成的是译码器的知识，

1）2-4译码器搭建3-8译码器我其实不太会，我就感觉应该整一个sel位，但是我不会加，有思路但是我不会实现，于是我百度了一下，找到了一个博主展示了带有sel位的2-4译码器，最后我进行了修改，完成了3-8译码器的组合。

2）七段数码译码器的连接一开始我特别晕，我都有点害怕了，看着提示我有有点不太懂，自己想了一个上午一个下午，最后还是是问了ai，点播了一下子就懂了，或许自己思路完后再问ai的效果更好。

感觉还是学到了很多东西的，加油！



### 编码器

#### 1.搭建16-4_encoder

![image-20260106163236477](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260106163236477.png)

**问：如何根据真值表写出逻辑表达式，从而写出门电路？**

答：看输出Y，找当Yi=1时所有的情况，同一种情况内的输入相与，不同情况之间相或，要保证连接所有的输入端，不能有遗漏。

**问：为什么七段数码译码器不同？**

答：因为这个不是连接所有的输入，而是哪个输入=1时，对应的段亮起，所以是当Yi=1时，把所有输入端Ai=1的情况利用或门相连。



**总结**：以上是两种方法，来设计门电路

第一种方法是根据真值表得出逻辑式，来设计门电路，但是门电路比较多，效率比较低；

第二种方法从结果Y入手，然后倒推输入，当Yi=1时，看哪些输入为1，连接或门。

|  A0  |  A1  |  A2  |  A3  |  A4  |  A5  |  A6  |  A7  | A8   | A9   | A10  | A11  | A12  | A13  | A14  | A15  |      |  Y3  |  Y2  |  Y1  |  Y0  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | :--: | :--: | :--: | :--: |
|  1   |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |  0   |  0   |  0   |  0   |
|      |  1   |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |  0   |  0   |  0   |  1   |
|      |      |  1   |      |      |      |      |      |      |      |      |      |      |      |      |      |      |  0   |  0   |  1   |  0   |
|      |      |      |  1   |      |      |      |      |      |      |      |      |      |      |      |      |      |  0   |  0   |  1   |  1   |
|      |      |      |      |  1   |      |      |      |      |      |      |      |      |      |      |      |      |  0   |  1   |  0   |  0   |
|      |      |      |      |      |  1   |      |      |      |      |      |      |      |      |      |      |      |  0   |  1   |  0   |  1   |
|      |      |      |      |      |      |  1   |      |      |      |      |      |      |      |      |      |      |  0   |  1   |  1   |  0   |
|      |      |      |      |      |      |      |  1   |      |      |      |      |      |      |      |      |      |  0   |  1   |  1   |  1   |
|      |      |      |      |      |      |      |      | 1    |      |      |      |      |      |      |      |      |  1   |  0   |  0   |  0   |
|      |      |      |      |      |      |      |      |      | 1    |      |      |      |      |      |      |      |  1   |  0   |  0   |  1   |
|      |      |      |      |      |      |      |      |      |      | 1    |      |      |      |      |      |      |  1   |  0   |  1   |  0   |
|      |      |      |      |      |      |      |      |      |      |      | 1    |      |      |      |      |      |  1   |  0   |  1   |  1   |
|      |      |      |      |      |      |      |      |      |      |      |      | 1    |      |      |      |      |  1   |  1   |  0   |  0   |
|      |      |      |      |      |      |      |      |      |      |      |      |      | 1    |      |      |      |  1   |  1   |  0   |  1   |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      | 1    |      |      |  1   |  1   |  1   |  0   |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      | 1    |      |  1   |  1   |  1   |  1   |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |



我利用了第二种办法设计了16-4encoder，但是未使用提示的拨码开关，原因是线太密集了，就舍弃了拨码开关。

![image-20260107165416996](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260107165416996.png)

#### 2.搭建4-2优先编码器

![image-20260107175844487](C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20260107175844487.png)

![image-20260107175337899](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260107175337899.png)



![image-20260107184308703](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260107184308703.png)

可化简为：

![image-20260110161658215](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110161658215.png)

则可设计门电路为：

![image-20260110162314437](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110162314437.png)

使用门电路数量（符合对等原则）

4-2编码器：2#(or) = 2 × 8 = 16

4-2优先编码器：#T(not)+#T(and3)+2*#T(or2)=2+(3-1)×8+2×8=34

可以看出还是4-2编码器实现所需的晶体管更少



###### 我的疑问：（已解决部分）

1.这咋看呀，感觉很难看出来是不是最简——**利用工具来化简**

2.常见的门电路的原理图要不要记住？



### 多路选择器

#### 1.搭建1位2-1_MUX

![image-20260104173623365](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260104173623365.png)

搭建如下图，必须同时满足Di=1和S选中，才会被选中

![image-20260108095210558](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260108095210558.png)

#### 2.搭建3位4-1_MUX

![image-20260108094245820](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260108094245820.png)



设计思路：3位的选择器，输入和输出都要满足3位，但选择器只能输出1位数据，所以利用分线器来进行位扩展，其余的思路与1位2-1_MUX一样，设计图如下，已通过测试：

![image-20260108101622139](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260108101622139.png)



#### 3.搭建可切换进位计数制的七段数码管

![image-20260108101734604](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260108101734604.png)

##### 设计思路：

1.需要两种显示方式，所以要使用2-1_MUX，按照题意，选择信号为1时是十六进制显示，而七段数码译码管本身就支持0-15的十六进制输出，所以MUX=1时直接连接七段数码译码管；

2.接下来解决十进制的显示问题，我个人设想的是0-9正常显示，当输入数据为10-15时，只显示数字“9”。

也就是十进制表示法中在处理10-15时出现了不同的结果，可以分为0-7和8-15，也分别对应A3=0和A3=1两种情况，不同的是A3的值，所以可以设置一个2-1_MUX来分别选择两种情况；利用2个3开关的拨码开关表示A3-A1分别对应0-8和9-15两种不同的情况，还有1个1开关的拨码开关用来表示A4；

A4可以当做2-1_MUX的信号量S，A4=0时显示0-7，A4=1时显示8-15（8显示数字“8”，9-15只显示数字“9”，后面说明设计）

我想在A4=1时数字“8”正常显示，在值为9-15时只显示数字“9”，那么就是说A4和A0正常操作，而无论A3和A2的值为多少，呈现的结果都为A3=A2=0，所以可以利用一个3输入的与门，规定其中输入固定为0，即A3与A2与零，出来值必为0

3.此外，由于选择器输出固定是1bit，无法更改，且七段数码译码器输入为4bit，所以需要分线器，以及涉及的与门和或门均需要4位输入和输出。

设计图如下：

![image-20260108171657961](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260108171657961.png)

##### 小结：

###### 值得记录的Bug和调试心得

哇，这个过程非常艰难，我感觉我解决问题的能力再一次提升了，不过这次是问了ai，它给了我一个小小的提示，就是在十进制的时候，0-7和8-15这两部分对应的A3是不同的，其余的它说的都没啥用，所以我也并未采用，以后可以学会这个思路——考虑不同情况的输出，输入是否有特点，然后进行适当的时候电路设计，非常有成就感的一次解决问题！



### 比较器

#### 1.搭建比较器

![image-20260108172350510](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260108172350510.png)

相同时，

![image-20260109092227608](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109092227608.png)

不同时，

![image-20260109092245421](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109092245421.png)

利用异或门+非门，搭建同或门



#### 2.搭建1位全加器

![](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109092338816.png)

1位全加器的真值表：

| A    | B    | Cin  | S    | Cout |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 0    |
| 0    | 1    | 0    | 1    | 0    |
| 0    | 1    | 1    | 0    | 1    |
| 1    | 0    | 0    | 1    | 0    |
| 1    | 0    | 1    | 0    | 1    |
| 1    | 1    | 0    | 0    | 1    |
| 1    | 1    | 1    | 1    | 1    |

**注意**：1位的全加器，所以A=1，B=1，Cin=1时，Cout=1，因为得数是11B

根据真值表列出逻辑表达式，化简得：

1）S=(A⊕B)⊕Cin；

2）Cout=AB+Cin*(*A⊕B)

##### 逻辑表达式公式总结：

![image-20260109111301915](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109111301915.png)

##### 运行bug：

S=(A⊕B)⊕Cin，不是三者一起异或，是先A异或B，再异或Cin

![image-20260109112206402](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109112206402.png)

修改：

![image-20260109112726533](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109112726533.png)

#### 3.搭建4位加法器

![image-20260109113328080](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109113328080.png)

##### 设计思路：

把一位加法器改成出四位加法器，判断是否有进位，只要有进位，over！×

把一位加法器变成子电路，四个一位加法器封装成一个4位加法器

下面是没有进位的，

![image-20260109122118904](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109122118904.png)

下面是有进位的，

![image-20260109122200643](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109122200643.png)

## F3.6——整数的编码

#### 1.搭建4位全减法器

![image-20260109152201769](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109152201769.png)

##### 设计思路：

先搭建1位全减法器，再组合4个1位减法器

1位减法器真值表（A减B）

|  A   |  B   | Cin  |  S   | Cout |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  0   |  0   |  1   |  1   |  1   |
|  0   |  1   |  0   |  1   |  1   |
|  0   |  1   |  1   |  0   |  1   |
|  1   |  0   |  0   |  1   |  0   |
|  1   |  0   |  1   |  0   |  0   |
|  1   |  1   |  0   |  0   |  0   |
|  1   |  1   |  1   |  1   |  1   |

##### 设计如下图

无借位的情况，即A0≥B0

![image-20260109184254954](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109184254954.png)

有借位的情况，即A0＜B0

![image-20260109184422928](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109184422928.png)

#### 2.搭建4位原码加法器

![image-20260109184442481](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260109184442481.png)

##### 设计思路：

![原码加法器设计思路](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/原码加法器设计思路.png)

##### 设计电路：

###### 情况1：同号

![image-20260110171807304](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110171807304.png)

###### 情况2：异号

异号时，|A|＞|B|

![image-20260110171742668](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110171742668.png)

异号时，|A|<|B|

![image-20260110172157000](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110172157000.png)

###### 单独测试：-0的情况

![image-20260110172240289](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110172240289.png)

可以看出，设计的电路完全通过了测试，就是太过复杂，应该可以优化

##### 关于设计电路反思：

先画一个思维导图，把想实现的功能都写出来，然后再进行设计电路



#### 3.搭建4位反码加法器

![image-20260110114235900](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110114235900.png)

设计思路：把所给反码转化成原码，然后利用原码的加法器进行加法，设计一个4bit反码器，再封装成子电路，拼接上原码加法器。

##### 设计的4bit反码器：

设计思路：当真值为正时，原码和反码相同，不进行转化；当真值为负时，反码除符号位均取反，即得到原码。

设计电路：

![image-20260110172747703](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110172747703.png)

##### 4bit反码加法器：

封装成子电路后拼接，可以看出-0情况也可正确计算。

![image-20260110172923346](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110172923346.png)



#### 4.检测补码加法是否发生溢出

![image-20260110175930963](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110175930963.png)

##### 一位补码加法真值表

|  A   |  B   | Cin  |  S   | Cout | 溢出 |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |  否  |
|  0   |  0   |  1   |  1   |  0   |  是  |
|  0   |  1   |  0   |  1   |  0   |  否  |
|  0   |  1   |  1   |  0   |  1   |  否  |
|  1   |  0   |  0   |  1   |  0   |  否  |
|  1   |  0   |  1   |  0   |  1   |  否  |
|  1   |  1   |  0   |  0   |  1   |  是  |
|  1   |  1   |  1   |  1   |  1   |  否  |

##### 化简逻辑表达式：

得出逻辑表达式 (notA and notB and C) or (A and B and notC)，再进行化简得（基于Q-M算法的自编小程序）

![image-20260110185751642](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110185751642.png)

##### 设计电路如下：![image-20260110185520053](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260110185520053.png)



## F3.7——时序逻辑电路

### 锁存器

#### 1.搭建SR锁存器

![image-20260111154146163](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260111154146163.png)

##### 设计思路：

为了避免出现震荡，所以只设置3种情况，R=0,S=1以及R=1,S=0以及R=0,S=0

当满足R=0,S=1时，无论Q的值是多少，输出Q=1；

当满足R=1,S=0时，无论Q的值是多少，输出Q=0；

当满足R=0,S=0时，输出Q=输入Q。

所以可以设置2个二路复用器，用来选择输出的支路，当2个拨码开关均为0时，选中输出Q。

##### 设计电路图：

![image-20260111173927510](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260111173927510.png)

#### 2.分析D_Latch的行为

![image-20260113085236940](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113085236940.png)

##### D_Latch的真值表

|  D   |  WE  |  S   |  R   |  Q   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   | 保持 |
|  0   |  1   |  0   |  1   |  0   |
|  1   |  0   |  0   |  0   | 保持 |
|  1   |  1   |  1   |  0   |  1   |

##### 分析D_Latch的行为

当WE=0时，意味着此时D锁存器不能写，S和R必都是0，Q保持；

当WE=1时，D只有2种情况，要么0要么1，所以S和R必有一个是1；

由此可以得出D_Latch可以避免出现震荡，并且WE来控制锁存器是否执行置位和复位功能。



#### 3.搭建D_Latch

![image-20260111183047158](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260111183047158.png)

##### 设计思路：

 “将SR锁存器的4种输入限制成3种合法输入, 这就是D锁存器的基本思想”——在SR锁存器的基础上进行修改，改成WE，D和Q输入位。×

注意！！D_Latch是没有输入端Q的，只有输出端Q，一定注意！！

所以，在SR锁存器的基础上进行修改，改成WE，D两个输入端。√

##### 设计电路图：

已通过所有测试

![image-20260113181113007](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113181113007.png)

#### 4.搭建带复位功能的D_Latch

![image-20260111183148197](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260111183148197.png)

##### 设计思路：

当Reset=0时，D_Latch是正常工作，与没有复位功能的D_Latch是一样的；

当Reset=1时，无论D_Latch此时是什么状态，最后输出Q=0。

所以可以在是在D_Latch的基础上进行修改，在最后的输出阶段加入一个三态门，如果Reset=1，则导通Q=0；Reset=0时，则正常导通D_Latch。

##### 设计电路图：

![image-20260113181136130](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113181136130.png)

#### 5.用D锁存器实现位翻转功能

![image-20260111183220622](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260111183220622.png)

##### 设计思路：

封装了带复位功能的D_Latch，然后将输出not_Q和输入端D连接。

##### 设计电路图：

当WE=0时，D锁存器不透明（即直接输出Q，锁存器不处理）

![image-20260113181352971](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113181352971.png)

当WE=1时，D锁存器透明（即锁存器处理Q再输出）：

挂起：按照理论电路应该震荡，但是我设计的电路并未震荡，我也没找到哪里有问题，所以这个bug挂起，待解决。

![image-20260113181249273](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113181249273.png)

于是我分离了输入D和输出not_Q,通过观察它俩的值和手动变换引脚来进行模拟翻转的原理。

##### 分析震荡原理：

当D_0=0时，则not_Q=1，若假设not_Q接上了D_0，且此时WE=1，故D可以影响Q，产生了反馈电路，所以此时D_0=1；

当D_0=1时，则not_Q=0，此时WE=1，故D依旧可以影响Q，同样产生了反馈电路，所以此时D_0=0；

如此循环往复，即产生了震荡。

![image-20260113181206740](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113181206740.png)

##### 分析震荡原因：

当WE=0时，D锁存器不透明，直接输出Q的值，此时D的值不能决定Q的值，反馈环路被阻断，振荡停止，输出保持原值。

当WE=1时，D锁存器透明，对于Q的值要进行处理再输出，此时D的值决定Q的值，反馈环路未被阻断，产生振荡，输出在0和1之间来回变化。



### 触发器

#### 1.搭建D触发器

![image-20260113142328552](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113142328552.png)

##### 设计思路：

主从式D触发器的工作过程：

主从式D触发器由两个D锁存器构成, 左边的称为主锁存器, 右边的称为从锁存器. 两个D锁存器的写使能端分别与时钟信号及其取反结果相连. 主从式D触发器的工作过程分为如下阶段:

1. 数据准备阶段. 此时时钟信号`clk`处于低电平, 故主锁存器的写使能端有效, 数据信号`D`可从外部进入主锁存器; 但由于从锁存器的写使能端无效, 故数据信号无法传播到从锁存器, 因而整个D触发器的输出端`Q`保持不变.
2. 采样阶段. 当时钟信号`clk`的上升沿到来时, 主锁存器的写使能端无效, 数据信号`D`无法从外部进入主锁存器, `D`的后续变化将无法对主锁存器造成影响, 从而将时钟信号上升沿到来前的外部数据`D`"锁"在主锁存器中. 与此同时, 从锁存器的写使能端开始有效, 主锁存器中"锁住"的数据将传播到从锁存器, 并作为整个D触发器的输出.
3. 维持阶段. 此时时钟信号`clk`处于高电平, 故主锁存器的写使能端无效, 因此不受数据信号`D`变化的影响; 从锁存器的写使能端虽然有效, 但由于主锁存器保持不变, 故从锁存器也保持不变, 因而整个D触发器的输出端`Q`保持不变.

##### 设计电路图：

主D锁存器的输出Q连接从D锁存器的输入D，按钮加非门连主D锁存器的WE，按钮直接连从D锁存器的WE。

当D=0，且低电平时，主D锁存器透明，此时Q=D=0，从D锁存器不透明；

当按下按钮，即高电平时，此时主D锁存器不透明，内部Q=0（封装锁存器中Q设为常数，0或1均不影响结果），从D锁存器透明，D=Q=1,，所以最后输出Q=1；

这样就不符合触发器的功能，应该按下按钮后输出Q即为输入D。

所以进行修改，问题出在主从连接的位置，低电平转高电平的时候从D锁存器的D段输入了错误的值，所以要保证在从D锁存器有效时，它的D收到的是正确的D，故连接一个三态门，在从D锁存器有效时，直接传入正确的D值。

另外，当三态门高阻态时，是不会报错的，因为输出的是Q的值，在子电路中Q为常数。（已经测试过不同Q值，不影响主从D主从触发器的功能）。

###### 主从式D_flip-flop：

![image-20260113183819061](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113183819061.png)

###### 封装的子电路D_Latch：

![image-20260113182115164](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113182115164.png)

#### 2.搭建带复位功能的D_flip-flop

![image-20260113145451736](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113145451736.png)

##### 异步复位：

只要点击Reset=1，则立刻复位为0。

![image-20260113184332072](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113184332072.png)

##### 同步复位：

当Reset=0，则高电平时复位为0，低电平不变；

当Reset=1，则与正常主从D触发器无区别。



#### 3.用D触发器实现位翻转功能

![image-20260113150056572](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113150056572.png)

##### 分析带有翻转功能的主从D_flip-flop：

只在上升沿的时候进行翻转一次，在下降沿的时候不进行翻转。（这是主从D_flip-flop的特点，经过百度上描述有的D触发器会在每一个上升沿和下降沿进行变化）

##### 翻转原理：

这个和翻转功能的D锁存器情况一样，依旧报错，于是我分离了输入D和输出not_Q,通过观察它俩的值和手动变换引脚来进行模拟翻转的原理。

D=1时，上升沿时输出Q=1，not_Q=0，另D=not_Q=0，翻转一次；

D=0时，上升沿时输出Q=0，not_Q=1，另D=not_Q=1，又翻转一次；

如此往复循环。

##### 设计电路图：

分离后的，

![image-20260113193056686](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113193056686.png)

爆红：

![image-20260113193203811](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113193203811.png)

#### 4.搭建带使能端的D触发器

![image-20260113141532938](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113141532938.png)

##### 设计思路：

利用2-1选择器进行来实现，选择是直接输出Q，还是要通过D触发来进行处理。E=1时选中D触发器，反之选中输入Q。

##### 设计电路图：

![](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113184610218.png)

### 寄存器

#### 1.搭建4位寄存器

![image-20260114085516084](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114085516084.png)

![image-20260113194908903](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260113194908903.png)

##### 设计思路：

按照提示的门电路搭建即可。

##### 设计电路图：

![image-20260114092221511](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114092221511.png)

#### 2.搭建4位计数器

![image-20260114092244448](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114092244448.png)

##### 设计思路：

每点一次CLK，则进行一次加一操作，所以加法器的2个加数，一个是1，而另一个是上一次的结果，但加法器没有存数功能，所以要把得数存到4位寄存器当中，于是所以add_1与4位寄存器的输出端相连。上升沿到来时，寄存器会把结果输送到add_1，由于加法器无时钟性的特点，同时也会再一次进行加1操作。

##### 设计电路图：

由4位寄存器和4位全加器组成的4位计数器

![image-20260114101909222](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114101909222.png)



4位寄存器，且带有同步复位功能。

![image-20260114175014058](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114175014058.png)



四位全加器

![image-20260114101801545](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114101801545.png)

#### 2.设计数列求和电路

![image-20260114115754459](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114115754459.png)

##### 设计思路：

我的想法是，假设0+a为一次相加的结果sum，sum再加上a+1，不断重复这个过程直到a=10。

所以可以利用上一个自增电路来完成a+1，再加一个加法器求得sum，考虑到结果会溢出，所以构建8位寄存器和8位加法器。

##### 设计电路图：

###### 数列求和电路：

当a=10时，sum=55（十进制）。

![image-20260114180417642](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114180417642.png)

###### 8bit寄存器：

![image-20260114180601589](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114180601589.png)

###### 8bit加法器：

![](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114180647926.png)



#### 3.实现电子时钟

![image-20260114113740778](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114113740778.png)

##### 设计思路：

秒个位满十，则秒十位加1；

秒十位满5，则分个位加1；

分个位满十，则分十位加1。

所以，可以看出，只要能满足“秒个位满十，则秒十位加1”，其余的电路逻辑是一样的。

秒个位＜10时，正常显示0-9；秒个位=10时，需要秒个位清零，秒十位加1。——利用时钟和自增线路实现自动从1到9，再利用选择器实现，设置常量10，与自增电路输出端比较大小，当＜10时，七端数码译码器正常显示0-9；当=10时，=端连接Reset端，实现秒个位清零，同时=端连接另一个计时器的CLK端，实现秒十位加1。不同的是，表示十位的计时器的比较器，需要设置常量=5。

一共设置4个计时器，时钟连秒个位的CLK，秒个位的=端连秒十位的CLK，秒十位的=端连分个位的CLK，秒十位的=端连分十位的CLK。

##### 设计电路图：

###### 部件时钟设置时间：

选择2.0HZ，启用时钟模拟则可实现自动。

![image-20260114160437639](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114160437639.png)

###### 电子时钟：

已经过测试，可以正常进位显示。

![image-20260114182225667](https://gitee.com/brownie145810/ysyx_pic/raw/master/ysyx_pic/image-20260114182225667.png)
